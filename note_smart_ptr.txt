1.Smart_ptr Intro
    Smart_pträ¸»è¦æ˜¯é¿å…memory leakçš„å•é¡Œ

    æœ‰æ™‚å€™å¯èƒ½newäº†æ±è¥¿å‡ºä¾†å¿˜è¨˜deleteï¼Œæˆ–æ˜¯åœ¨ä¸€äº›æ¯”è¼ƒè¤‡é›œçš„æƒ…æ³ä¸‹ä½ å¯èƒ½ä¸çŸ¥é“ä½•æ™‚è©²delete

    ç•¶ç„¶è¨˜æ†¶é«”ç®¡ç†å°æ–¼C++ä¾†èªªæ˜¯éå¸¸é‡è¦çš„ï¼Œå°æ–¼é–‹ç™¼è€…ä¾†èªªä¹Ÿæ˜¯å¾ˆé‡è¦çš„åŸºæœ¬åŠŸ

    ä½†å¦‚æœéƒ½èƒ½ç”±ç³»çµ±ä¾†handleè¨˜æ†¶é«”ç®¡ç†çš„äº‹æƒ…ï¼Œåœ¨é–‹ç™¼ä¸Šæœƒçœå»å¾ˆå¤šéº»ç…©

    åœ¨C++11(æˆ–ä»¥å¾Œ)çš„ç‰ˆæœ¬ï¼ŒSTLè£¡é¢å°±æœ‰æä¾›é€™æ¨£çš„æ±è¥¿

    ä¸»è¦åˆåˆ†æˆä¸‰ç¨®ï¼šunique_ptrã€shared_ptrã€weak_ptr

    1-1.ç”¨æ³•
        1-1-1.ä½¿ç”¨ä»–å€‘ä¸‰å€‹æ™‚è¦ #include <memory>
        1-1-2.å‰µå»ºæ™ºæ…§æŒ‡æ¨™:
            smart_ptr<å‹æ…‹> ptr( new å‹æ…‹çš„å»ºæ§‹å­ ) //newå»ºæ§‹å­å¯ä»¥æ±ºå®šè¦ä¸è¦å¸¶åƒæ•¸
            ä¹Ÿå¯ä»¥ç”¨: smart_ptr<å‹æ…‹> make_shared<å‹æ…‹>(->å¦‚æœæœ‰åƒæ•¸å°±æ”¾é€™<-)

3.shared_ptr
    3-1.Intro
    std::shared_ptr æ˜¯å¯ä»¥è®“å¤šå€‹ std::shared_ptr å…±äº«ä¸€ä»½è¨˜æ†¶é«”ï¼Œ
    ä¸¦ä¸”åœ¨æœ€å¾Œä¸€å€‹ std::shared_ptr ç”Ÿå‘½é€±æœŸçµæŸæ™‚æ™‚è‡ªå‹•é‡‹æ”¾è¨˜æ†¶é«”ï¼Œ

    3-2.ç”¨æ³•
        3-2-1.
            shared_ptr<int> a;
            shared_ptr<int> b(new int(5));
            a=b;

            // release ptr b, but ptr a exist, 
            //so memory dosen't be released. counter = 5.

            cout << *a;

        3-2-2.å¸¸ç”¨function
            .use_count()
                ç”±å…¶ä¸­ä¸€å€‹shared_ptrå‘¼å« ç”¨ä¾†æŸ¥çœ‹æœ‰å¹¾å€‹shared_ptrå…±ç”¨åŒä¸€å¡Šè¨˜æ†¶é«”
                å¦‚æœé€™æ¨£å¯«:
                shared_ptr<A> ptr2 = ptr1;
                .use_count()å›å‚³å€¼å°±+1

            .reset()
                ç”±å…¶ä¸­ä¸€å€‹shared_ptrå‘¼å«ï¼Œæ‰‹å‹•é‡‹æ”¾ é€™å€‹share_ptrå°è¨˜æ†¶é«” çš„æ‰€æœ‰æ¬Š
                shared_ptrçš„åƒè€ƒè¨ˆæ•¸-1

            .get()
                å›å‚³å…§éƒ¨çš„è£¸æŒ‡æ¨™(new)ï¼ˆä¸å»ºè­°å¸¸ç”¨ï¼Œé™¤éå¿…è¦ï¼‰
                shared_ptr<int> p = make_shared<int>(42);
                int* raw = p.get();  // å–å¾—è£¸æŒ‡æ¨™ï¼Œä½†ä¸è² è²¬ deleteï¼

            .unique()
                æª¢æŸ¥è‡ªå·±æ˜¯å¦æ˜¯å”¯ä¸€æŒæœ‰è€…ï¼ˆuse_count == 1ï¼‰ã€‚
                shared_ptr<int> p1 = make_shared<int>(100);
                shared_ptr<int> p2 = p1;
                cout << p1.unique() << endl;  // falseï¼ˆuse_count == 2ï¼‰
                p2.reset();
                cout << p1.unique() << endl;  // trueï¼ˆuse_count == 1ï¼‰

            .swap(shared_ptr<T>& other)
                èˆ‡å¦ä¸€å€‹ shared_ptr äº¤æ›ç®¡ç†çš„è³‡æºã€‚
                shared_ptr<int> a = make_shared<int>(10);
                shared_ptr<int> b = make_shared<int>(20);

                a.swap(b);
                // ç¾åœ¨ a æ˜¯ 20, b æ˜¯ 10

            operator*() / operator->()
                è§£åƒè€ƒæ“ä½œï¼Œå¯ä»¥åƒæŒ‡æ¨™ä¸€æ¨£ä½¿ç”¨ç‰©ä»¶ã€‚
        
        3-2-3.èˆ‡å·¥å» å‡½å¼(Factory Function) æ­é…:

            #ã€Œå·¥å» å‡½å¼ã€æ˜¯ä¸€ç¨®ç”¨ä¾†å»ºç«‹ç‰©ä»¶çš„å‡½å¼ï¼Œå®ƒå°è£äº†ç‰©ä»¶çš„å»ºç«‹ç´°ç¯€ï¼Œ
            è®“ä½¿ç”¨è€…ä¸ç”¨çŸ¥é“ newã€å»ºæ§‹å­åƒæ•¸ã€åˆå§‹åŒ–é‚è¼¯ç­‰ç­‰ï¼Œ
            åªè¦å‘¼å«é€™å€‹å‡½å¼å°±èƒ½å®‰å…¨åœ°æ‹¿åˆ°ä¸€å€‹å»ºå¥½çš„ç‰©ä»¶ã€‚

            å„ªé»:
                âœ… éš±è—å»ºæ§‹ç´°ç¯€ï¼ˆå°¤å…¶æ˜¯è¤‡é›œçš„åˆå§‹åŒ–éç¨‹ï¼‰

                âœ… æ§åˆ¶å»ºç«‹ç‰©ä»¶çš„æ–¹å¼ï¼ˆä¾‹å¦‚å›å‚³ shared_ptr æˆ– unique_ptrï¼‰

                âœ… å¼·è¿«ä½¿ç”¨ heap å»ºç«‹ç‰©ä»¶ã€é¿å…éŒ¯èª¤ä½¿ç”¨æ–¹å¼

                âœ… å¯ä»¥æ”¹ç‚ºå›å‚³å·²ç¶“å»ºç«‹çš„å…±ç”¨å¯¦ä¾‹ï¼ˆsingleton or poolï¼‰

                âœ… å°è£ç‰©ä»¶å»ºç«‹é‚è¼¯

                âœ… å¯å›å‚³æ™ºæ…§æŒ‡æ¨™ï¼Œè‡ªå‹•è¨˜æ†¶é«”ç®¡ç†

                âœ… å¯é™åˆ¶å»ºæ§‹å­å­˜å–æ¬Šé™ï¼ˆè¨­ç‚º privateï¼‰

                âœ… æ›´ä¸€è‡´ã€æ›´å®‰å…¨çš„å»ºç«‹ä»‹é¢
                            

            ä¾‹å­1:
                class MyClass {
                public:
                    MyClass(int x) {
                        // è¤‡é›œåˆå§‹åŒ–...
                    }

                    static MyClass create(int x) {
                        return MyClass(x);  // å‚³å€¼å»ºç«‹
                    }
                };

                ä½¿ç”¨æ™‚: MyClass obj = MyClass::create(42);


            ä¾‹å­2(é…åˆsmart_ptr):
                                    //æ¨™é ­//

                class Maze;
                class Player;

                class Obstacle : public Block {
                private:
                    struct SharedData {
                        int hp;
                        std::vector<std::pair<int, int>> positions;
                        Maze* maze;
                    };

                    std::shared_ptr<SharedData> data;

                    // ç§æœ‰å»ºæ§‹å­ï¼Œå¤–éƒ¨ç„¡æ³•ç›´æ¥ new
                    Obstacle(std::shared_ptr<SharedData> shared);

                                    //å…¶ä»–data member//

                public:

                    // å·¥å» å‡½å¼ï¼Œå»ºç«‹ä¸€çµ„éšœç¤™ (æœƒè‡ªè¡Œå»ºç«‹ SharedData ä¸¦åŠ å…¥æ‰€æœ‰ä½ç½®)
                    static std::shared_ptr<Obstacle> create(Maze* maze, 
                        const std::vector<std::pair<int, int>>& positions);

                                        //å…¶ä»–method//
                };

                #endif

                //.cpp

                    // ç§æœ‰å»ºæ§‹å­
                    Obstacle::Obstacle(std::shared_ptr<SharedData> shared) : data(shared) {}

                    // éœæ…‹å·¥å» å‡½å¼
                    std::shared_ptr<Obstacle> Obstacle::create(Maze* maze, 
                        const std::vector<std::pair<int,int>>& positions) 
                    {
                        auto shared = std::make_shared<SharedData>();
                        shared->hp = 2  // åˆå§‹è¡€é‡
                        shared->maze = maze;
                        shared->positions = positions;  // ä¸€æ¬¡å‚³å…¥æ‰€æœ‰ä½ç½®

                        // æ”¹æˆ new ä¸¦ç”± shared_ptr ç®¡ç†ï¼Œé¿å… private å»ºæ§‹å­è¡çª
                        return std::shared_ptr<Obstacle>(new Obstacle(shared));
                    }

            ä½¿ç”¨æ–¹å¼: auto obs = Obstacle::create(maze,positions)


            ğŸ§  ç‚ºä»€éº¼å·¥å» å‡½å¼å¥½ç”¨ï¼Ÿ

            å‚³çµ±ä½œæ³•	                        å·¥å» å‡½å¼ä½œæ³•
            auto p = new A(...);	            auto p = A::create(...);
            auto p = make_shared<A>(...);	    auto p = A::create(...);
            constructor ç´°ç¯€å¤–éƒ¨å¯è¦‹	         constructor å¯ä»¥è¨­æˆ private
            æ˜“æ–¼èª¤ç”¨ï¼ˆè¨˜æ†¶é«”æ´©æ¼ï¼‰	              å®‰å…¨å›å‚³æ™ºæ…§æŒ‡æ¨™ï¼Œé˜²æ´©æ¼`


                








